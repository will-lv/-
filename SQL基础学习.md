### SQL基础学习（附SQL题库）

数据库语言，所有的关系型数据库管理系统都将SQL作为其标准处理语言，对于数据分析师来说，主要掌握里面的查询功能

#### 基础语法（能满足80%的查询需求）

select            选择你要的字段

from              指定引用的库表

where           筛选采摘你要的信息

group by       根据某字段聚合

having           聚合后结果重新选择

join

​	left/right join     保留左/右表（上为左，下为右）全部信息

​	inner join           保留左右表匹配信息

​	full join			   保留左右表全部信息

##### 开窗函数

基础语法：over(partition by XX order by xx)

可搭配聚合函数使用

某个字段单独针对选定字段聚合，group by相当于开门，所有字段都要聚合。over相当于开窗，只聚合over后的选用字段并排序。

在hive里有over函数就不能使用group by函数，如果对所有指标都进行一样的开窗（partition by后面跟这个字段相同），那么就等于不去重处理的group by函数

##### 其他函数

###### 聚合函数（配合group by和开窗使用）

count（计数）

sum （求和）

avg （平均）

percentile_approx（分位数）

max（最大值）

collect_list/collect_set（行列归并计算）

###### 时间函数

current_date（获取当前日期）

to_date（日期时间转日期格式）

from_unixtime（unix时间戳转时间格式）

date_format（日期、时间戳、字符串类型格式化输出标准时间格式）

unix_timetamp（获取当前时间的unix时间戳和日期转unix时间戳函数）

year/quarter/month/day（返回日期中的年/季度/月/日）

hour/minute/second（返回日期中的时/分/秒）

weekofyear（返回日期在当年的第几周）

datediff（日期比较函数，返回开始日期减去结束日期的天数）

date_sub（日期减少函数，返回日期前n天的日期）

months_between（返回两个日期之间的包含的月数，结果为double类型）

last_day（获取日期当月最后一天）

##### SQL调优

###### 创建索引

减少运算量

###### 避免索引上直接计算

如果索引列时计算或函数的一部分，DBMS的优化器将不会使用索引二使用全表查询

###### 尽量压缩一条sql语句

能够压缩一句SQL执行的语句就不要用多条来执行

###### 用where替换having

having只会在检索出所有记录之后才对结果进行过滤，而where则是在聚合前刷选记录使用的表的别名

###### 请使用表的别名

请使用表的别名并把别名前缀与每个列名上

#### SQL题库

##### 一、基础面试简答题

###### **a.SQL中有很多常用的统计函数，其中一些包括：**

**常用**：

1.count（列名）：统计表中指定列额非空值的数量

2.avg（列名）：计算指定列的平均值

3.max（列名）：返回指定列的最大值

4.min（列名）：返回指定列的最小值

5.sum（列名）：计算指定列的总和

**不常用**：

1.stdev（列名）：返回指定列的标准差

2.stddevp（列名）：返回指定列的百分位数标准差

3.var（列名）：返回指定列的方差

4.varp（列名）：返回指定列的百分位数方差

5.percentile/percentile_approx（列名）：返回指定列（或数组）的分位数（0.5为中位数）

###### **b.SQL中哪些字符串操作有哪些常用的函数**

SQL中很多常用的字符串操作函数，其中一些包括：

1.left(str,len)：返回字符串str的前len个字符

2.right(str,len)：返回字符串str的后len个字符

3.subbtring(str,start,len)：返回字符串str从start位置开始长度为len的子串

4.upper(str)：将字符串str转换为大写

5.lower(str)：将字符串str转换为小写

6.trim(str)：去除字符串str两端的空格

7.replace(str, old_substring, new_substring)：将字符串str的old_substring替换为new_substring

8.instr(str1, str2)：查找字符串str2在str1中第一次出现的位置

9.length(str)：返回字符串str的长度

10.concat(str1, str2):链接两个字符串并返回结果

11.concat_ws(separator,str1, str2, ...)：用分隔符将多个字符串连接起来

12.group_concat([distinct]要连接的字段[order by 排序字段 asc/desc]\[separator '分隔符'])：分组聚合，将多个值连接成一个字符串

13.substring_index(string, '切割标志'， 位置数（负号：从后面开始）)：用于从给定的字符串中提取子字符串

**对于字符串的操作，举个例子：当我们清洗一些文字字符串的时候，会先用trim去掉空格，再把字母都转为小写lower，然后用regexp_replace把不需要的字符替换掉，再截取或者组合自己需要的字符串**

###### **c.SQL中哪些常用日期函数**

1.date_add：对指定起始时间进行加减操作

2.last_day：所在月份的最后一天

3.dayofweek：返回整数从'1'到'7'，表示星期日到星期六

4.datediff（time_end，time_start）：计算两个日期之间间隔的天数  日期差

5.date_format(date，format)：date_format(’2018-06-01 12:12:12", '%Y/%d/%m')返回2018/01/06

6.timestampdiff(unit, time_start, time_end)：可计算指定单位的时间差

**日期函数是实际工作中需要全面了解或做笔记的，储存一个日期函数笔记即可，不一定要真的背下来，更需要知道【对日期的大部分处理需求sql都可以满足，而针对日期的趋势分析是初级分析的大头】**

###### **d.sql随机从表中提取数据用什么函数**

使用rand()函数，结合使用order by对数据排序，用limit N取topN来随机从表中提取数据。例如，要随机选择5条记录，可以使用以下SQL语句：

```sql
select * from table_name order by rand() limit 5;
```

**这个函数会应用在【抽样提取】的需求中，当然，，实际工作中会有更好的，不需要SQL来做的办法，但基本也不属于数据分析师的工作，更多是在研发侧（如正交分流）**

###### **e.sql中空字符串，0、NULL和FALSE的区别**

在SQL中，空字符串（‘’）、0和NULL代表不同的含义

- 空字符串（‘’）表示一个空值或空文本。如果一个列中存储的是空字符串，那么这个列的值是存在的，但是它的长度为0
- NULL表示未知值或不存在的值。如果一个列存储的是NULL，那么这个列的值是不存在的，无法标胶大小或相等，也不能进行算术运算。NULL不等于任何值，包括它本身。
- FALSE是一个布尔值，它表示为0，使用布尔数据类型来存储。当将一个值插入到一个布尔类型的列中时，可以使用1或0来表示TRUE和FALSE。一个未知的值会被自动转换为NULL

**需要注意的是，在统计中，空字符串‘’、0、FALSE都会被统计到，而定义为NULL不会被统计到，如果该列值需要被统计，良好的编程习惯是把未知项定义为null**

| count('') | count(0) | count('0') | count(null) | coount(FALSE) |
| --------- | -------- | ---------- | ----------- | ------------- |
| 1         | 1        | 1          | 0           | 1             |

###### **f.count(1)、count(*)、count(distinct a)、count(a)的区别**

- count(1)：根据第一列统计计算表中行的数量，包含重复的记录，包含为NULL或空的值。也可以使用count(2)、count(3)等等。
- count(*)：计算表中行的数量，与count(1)的效果相同，但是它会对每一列进行计数，因此可能会稍微慢一些。不会去掉某个列为空的数据。
- count(distinct a)：根据指定的列统计行数，不包含重复的记录，不包括NULL或空的值
- count(a)：根据指定的列统计记录总数，包含重复的记录，不包括NULL或空的值

**这道题和上面的null又有点不同，例如，在定义的序列(0，null，‘’，11)中，上述函数的结果如下，这意味着即使某一行中存在null的时候，count(1)依然会如实统计行数，但是在记录count(a)的时候，null又不会被统计到**

| count(1) | count(*) | count(distinct a) | count(a) |
| -------- | -------- | ----------------- | -------- |
| 5        | 5        | 3                 | 4        |

###### **g.如何将int类型的字段转换为string字段**

可以使用cast()或convert()函数将int类型的字段转换为string字段

```sql
select cast(int_column as char) from table_name;
select convert(int_column, char) from table_name;
```

**不同数据类型的值可能会导致：无法union组合，无法相加，无法作为case when的结果等，所以保证数据类型已知是一个良好的习惯**



###### **h.sql中字符串有哪些常见的数据类型**

- char(m)定长字符串，m代表字符串的长度，最毒可容纳255个字符。查询速度快，查询比较多。浪费空间
- varchar(m)变长字符串，m代表字符串的长度，最多可容纳65535个字节。（utf8 一个字符3个字节），空间利用效率高。
- text保存变长的大字符串，最多65535（2^16 -1 ）个字符。用于长文：文章、新闻等。
- nchar(n)：固定长度的Unicode字符串，其中n是字符串的最大长度
- nvarchar(n)：可变长度的Unicode字符串，其中n是字符串的最大长度



###### **i.sql中like和rlike有什么区别**

like和rlike都是用于模糊匹配的关键字。

- like是通配符，必须完全匹配。可以使用：_匹配任意一个字符，%匹配0个或多个字符
- rlike是正则表达式，也可以用regexp

**延申阅读：正则表达式是一种用来描述和匹配一系列符合某个语法规则的字符串的方法。在SQL中，正则表达式可以用来进行模糊查询，提取或替换文本，验证输入格式等操作。不同的数据库可能支持不同的正则表达式语法和函数，因此您需要根据您使用的数据库来选择合适的方法。**



###### **j.SQL中on，where和having的区别**

ON、WHERE和HAVING都是用于过滤数据的关键字

- ON是用于连接两个或者多个表的子句，WHERE是用于过滤数据行的子句，而ON和WHERE都可以用于内连接（inner join)查询。
- 对于外连接（outer join）查询，ON中的过滤条件在连接操作之前执行，WHERE中的过滤条件（逻辑上）在连接操作之后执行。
- HAVING是用于过滤分组结果的子句，它通常与GROUP BY一起使用，可以使用聚合函数筛选，where中不能使用聚合函数筛选。

**要注意hive的语法里面，on不能用于不等式的链接，也就是只能on a = b，不能on a > b，但是在mysql内可以**



###### **k.SQL中in和exists的区别**

IN和EXISTS都是用于子查询的关键字

- IN用于基于一组固定值进行比较，判断主查询中的某个列是否等于子查询中返回的结果集中的任何一个值。
- EXISTS判断查询结果集是否为空，与主表关联时，会进行一行行查询，过滤掉主查询中不存在的，留下存在的。EXISTS能判断多列比较，IN只能判断一列比较。
- 在查询效率上，一般情况下，如果子查询得出的结果集记录较少，主查询的表较大且又有索引时应该用IN，反之如果外层的主查询记录较少，子查询中的表大又有索引时使用EXISTS



###### **l.SQL如何优化才能解决数据倾斜类问题**

数据倾斜是指在sql查询中，某些表或列的分布不平衡，导致查询效率低下。以下时一些可能有用的优化技巧：

1.在表上使用合适的分布键（distribution key）和排序键（sort key），以确保数据均匀地分布在群集中。

2.把大表拆分成多个小表，使用JOIN或者UNION ALL进行关联处理，减少单个表地数据量。

3.让查询尽可能走索引，避免全表扫描，可以使用EXPLAIN获得查询计划，并做出相应地调整。

4.避免使用过多地where子查询，尤其时嵌套地子查询，会增加查询地时间复杂度。

5.对于GROUP BY和ORDER BY操作，要考虑是否需要在分布键或排序键上进行操作，以最大程度利用分布式数据库系统地并行处理能力

6.如果数据倾斜问题无法通过优化查询来解决，则可能需要重新设计数据模型或使用更高级的数据仓库工具来处理。

**案例：假设有一个订单表orders，包含以下字段：order_id,coustomer_id,order_date,total_amount--假设查询中经常需要按照年份进行分析，那么可以将orders表拆成多个年份分区的表，例如oders_2020，oders_2021等--然后再查询时，根据需要选择相应的表进行JOIN或者UNION ALL操作--例如，查询2020年和2021年的订单总额**

```sql
select year(order_date) as year,sum(total_amount) as total
from
(select * from orders_2020 
union all
select * from orders_2021) as t
group by year(order_date);
```



###### **m.如何优化SQL查询语句**

SQL查询优化时一个复杂的过程，需要结合具体情况进行分析和优化。以下是一些可能有用的技巧：

1.索引查询：确保SQL中使用了正确的索引，避免全表扫描。可以使用EXPLAIN或其他性能调试工具来检查计划和索引使用情况。

2.数据看范式化：通过将数据拆分成更小的表，并建立适当的关系，提高数据的规范化程度和查询效率。

3.合理使用JOIN：在使用JOIN时，要考虑到JOIN的顺序、连接类型以及连接字段等因素，以确保查询尽可能地使用索引并减少数据传输。

4.避免使用大型临时表：如果必须使用临时表，可以使用内存表或者临时表缓存技术，减少磁盘IO操作次数

5.避免使用ORDER BY子句中的函数：ORDER BY子句中地函数会导致数据库进行计算，从而降低查询效率。因此，在可能地情况下，应该尽量避免在ORDER BY子句中使用函数

6.避免使用通配符：在WHERE子句中，尽量避免使用%来匹配文本，这样会导致全表扫描。

7.减少子查询次数：每个子查询都需要执行一个查询操作，尽量避免嵌套次数太多的子查询

8.使用UNION ALL而不是UNION：如果查询结果集的中间结果没有重复行，则可以使用UNION ALL代替UNION，避免排序操作。

9.缓存数据：对于一些只读的查询，可以使用缓存技术将结果集缓存在内存，以避免重复查询。

**SQL语句的优化属于【良好的编程习惯】所以不仅仅是记下上面的答案，而是在日常工作中练习和使用（会遇到很多实际问题），例如第三点【合理使用join】的结果可能是：如果你有需要多次join关联的临时表，建议提给数据仓库做成更普适的宽表，来提高表的运行和输出的效率，这些内容体现在工作中的方方面面**



###### **n.SQL去重的方法有哪些**

在SQL中，有很多种方法可以去重。以下是一些常见的方法：

1.使用DISTINCT关键字：在SELECT语句中使用DISTINCT关键字，可以去掉查询结果集中的重复行。

2.使用GROUP BY子句：将查询结果按照某个字段或多个字段进行分组，在分组后使用聚合函数（COUNT、SUM等）可以去重并统计数据。

3.使用子查询：在一个SELECT语句内嵌套另一个SELECT语句，通过WHERE子句和EXISTS或NOT EXISTS子句来进行查询

4.使用UNION或UNION ALL操作符：将多个SELECT语句的结果集合并成一个结果集，使用UNION可以去除重复行，而UNION ALL可以保留重复行。

5.使用临时表：将查询结果插入到一个临时表中，然后再从临时表中进行查询操作，可以进行去重操作。

6.使用窗口函数：再SELECT语句中使用窗口函数（如RANK、ROW_NUMBER等），可以对查询结果集进行排序和分组，同时去重。



###### o.简述下SQL查询语句的执行顺序，要包含窗口函数

如果查询包含窗口函数，那么窗口函数会在SELECT子句执行之前被计算。具体来说，窗口函数的计算顺序如下：

1.FROM和WHERE子句：构造源表和筛选数据

2.PARTITON BY子句：将数据划分为不同的分区

3.ORDER BY子句：按照指定的列排序

4.窗口框架：去欸的那个每一行的窗口范围

5.窗口函数：再每个窗口内计算函数值

6.SELECT子句：从临时表中选择需要的列

7.ORDER BY子句：按照指定的列排序

8.LIMIT或OFFSET子句：限制查询返回的结果集行数或跳过指定数量的行

**执行顺序是一个很重要的概念，他并非是一个一定要记的知识点，而是帮助你纠正书写思维，也就是数据分析师通常是按照计算顺序来写SQL**
![image](https://github.com/will-lv/data-analysis-foundation-map/assets/97819830/243234d4-3cad-432e-aa9d-030e7375de3c)
###### p.几种排序窗口函数的区别

- rank()  over()      1   2    2    4    4    6 （计数排名，跳过相同的几个，eg.没有3没有5)   美式排名

```sql
SELECT
  value,
  rank() OVER (ORDER BY value) AS rank
FROM
  (VALUES (1), (2), (2), (4), (4), (6)) AS t(value);

```

![image-20240118162558079](C:\Users\吕佩洁\AppData\Roaming\Typora\typora-user-images\image-20240118162558079.png)

![image-20240118161654849](C:\Users\吕佩洁\AppData\Roaming\Typora\typora-user-images\image-20240118161654849.png)

- row_number() over()     1  2   3   4   5   6    （赋予唯一排名）  中式排名
- dense_rank() over()  1  2  2  3  3  4   （不跳过排名，可以理解为对类别进行计数）
- percent_rank() over()  1  2  2  3  3  4    按照数字所在的位置进行百分位分段  计算方法为（RANK - 1)/(N - 1)   0，0.5，1

**备注：rank()窗口函数的排序值为bigint unsigned类型，所以详见出负数时会报错，需要进行强制类型转换。**

```sql
cast(rk1 as signed)-cast(rk2 as signed) as rank_diff
```



###### q.partition by和group by的区别

- GROUP BY用于在查询结果几种根据给定的列对数据进行分组，常与聚合函数一起使用
- PARTITION BY用于窗口函数中，它将结果集分成一组行（window)，并为每组行计算一个单独的聚合值，然后将该聚合值添加到源表的每个行中。

**partition by和窗口函数一起出现，是常考的题目，就算不考简答题也会考综合题，因为它比较抽象**



**r.什么是笛卡尔积，笛卡尔积问题一般出现在什么场景**

笛卡尔积（Cartesian Product）是指对两个或多个表进行无条件连接，返回的结果是这些表中的所有可能的组合。所有连接方式都会先生成临时笛卡尔积表，笛卡尔积是关系代数里的一个概念，表示两个表中的每一行数据任意组合。

笛卡尔积问题通常出现在以下场景：

1.没有明确指定连接条件的JOIN查询。当前查询中忘记指定join语句或忘记提供连接条件时，MySQL会默认执行笛卡尔积操作。这可能导致结果集迅速膨胀，产生大量不必要的数据。

2.子查询中使用了不相关的表或视图，导致数据重复。

3.在数据仓库或OLAP系统中，使用多个维度表进行联接查询时，容易产生笛卡尔积。

**为避免笛卡尔积问题，应注意以下几点：**

1.明确指定连接条件：在查询中使用join语句，并确保为每个连接提供正确的连接条件，以明确定义表之间的关联。

2.检查连接条件的准确性：确保连接条件中使用的列与表之间的关联是准确的，以避免错误的笛卡尔积结果。

3.使用合适的连接类型：根据业务需求选择适当的连接类型（如INNER JOIN、LEFT JOIN、RIGHT JOIN等），以避免不必要的笛卡尔积产生。



###### s.SQL中有哪些表连接方式

在SQL中，有以下几种表连接方式：

1.内连接（inner join)：内连接是最常用的连接方式，它只返回两个表中满足连接条件的行。在内连接中，使用JOIN或INNER JOIN关键字指定要连接的表，并使用ON子句来指定连接条件。

2.左连接（left join）：左连接是将左表的所有行与右表满足连接条件的行进行连接。如果右表中没有与左表匹配的行，则右表的值为NULL。在左连接中，使用LEFT JOIN关键字来指定要连接的表。

3.右连接（right join）：右连接是将右表的所有行与左表中满足连接条件的行进行连接。如果左表中没有与右表匹配的行，则左表的值为NULL。在全连接中，使用FULL JOIN或FULL OUTER JOIN关键字来指定要连接的表。

4.全连接（full join）：全连接是将左表和右表中所有行都进行连接，无论是否满足连接条件。如果某一侧没有匹配的行，则对应的值为NULL。在全连接中，使用FULL JOIN或FULL OUTER JOIN关键字来指定要连接的表。

5.自连接（self join）：自连接是将同一张表中的行进行连接。它通常用于需要比较表中不同记录之间的关系的情况。在自连接中，需要给同一张表取别名，并使用ON子句指定连接条件。

6.交叉连接（cross join）：交叉连接是对两个表进行笛卡尔积操作的结果，它将左表中的每一行都与右表中的每一行进行连接。在交叉连接中，使用cross join关键字来指定要连接的表。
